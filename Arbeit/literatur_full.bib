@book{Apelt.2012,
 year = {2012},
 title = {{H}andbuch {O}rganisationstypen},
 keywords = {Organisation;Typologie;Organisationssoziologie},
 address = {Wiesbaden},
 publisher = {Springer VS},
 isbn = {3531933124},
 editor = {Apelt, Maja}
}


@book{Sommerville.2007,
 author = {Sommerville, Ian},
 year = {2007},
 title = {{S}oftware-{E}ngineering},
 address = {M{\"u}nchen and Boston [u.a.]},
 edition = {8.},
 publisher = {Pearson Studium},
 isbn = {9783827372574},
 series = {{I}nformatik}
}


@book{Richards.2015,
 author = {Richards, Mark},
 year = {2015},
 title = {{M}icroservices vs. {S}ervice-{O}riented {A}rchitecture},
 address = {Sebastopol},
 publisher = {O'Reilly Media}
}


@book{Newman.2015,
 author = {Newman, Sam},
 year = {2015},
 title = {{B}uilding microservices: {D}esigning fine-grained systems},
 address = {Sebastopol and CA and USA},
 edition = {1.},
 publisher = {O'Reilly Media},
 isbn = {978-1491950357}
}


@book{Muhl.2006,
 abstract = {The field of event-based systems is surprisingly broad. In many scientific communities,technical talks, commercial products, and industrial projects people think about asynchronous computations and messaging, scalability and maintainability, stepwise evolution and loose coupling. Most likely, these people are discussing event-based systems, even if they use other terms. 
When we began investigating event-based systems some years ago, we were surprised to see that eventing was scattered among many disciplines of computer science. There were no workshops or conferences dedicated to this topic, for example, although many aspects of event-based systems cannot be assessed from a database, network, or software engineering perspective alone. In the same sense, commercially available products that could help solving problems of event-based architectures are often bundled and marketed in solutions of a specific domain. 
In order to channel some of the attention, the Distributed Event-Based Systems (DEBS) workshop series was created. It attracts people from distributed computing, database, and software engineering audiences, and it demonstrates the wide variety of facets event-based systems have. After having heard about and being engaged in interesting discussions about allegedly ``academic'' and ``real-world'' problem, in investigating many findings, and after creating many solutions in both academic and industrial environments, we decided to write this book to present both the current state-of-the-art and its base concepts. 
The book takes a distributed system's point of view. This is, of course, partly due to our own background, but more importantly we believe a solid understanding of distributed event-based systems is a good starting point for building modern computing systems. It lets you integrate sophisticated filter and data processing capabilities as well as new network topologies and routing algorithms.},
 author = {M{\"u}hl, Gero and Fiege, Ludger and Pietzuch, Peter},
 year = {2006},
 title = {{D}istributed event based systems},
 address = {Berlin and Heidelberg and New York},
 publisher = {Springer},
 isbn = {3-540-32651-0}
}


@book{Melzer.2010,
 author = {Melzer, Ingo},
 year = {2010},
 title = {{S}ervice-orientierte {A}rchitekturen mit {W}eb {S}ervices: {K}onzepte - {S}tandards - {P}raxis},
 keywords = {Computer industry;Computer science;Information systems;Software engineering;Text processing (Computer science);Serviceorientierte Architektur;Web Services},
 address = {Heidelberg},
 edition = {4},
 publisher = {Spektrum Akademischer Verlag},
 isbn = {3827425506}
}


@book{Krafzig.2007,
 author = {Krafzig, Dirk and Banke, Karl and Slama, Dirk},
 year = {2007},
 title = {{E}nterprise {S}{O}{A}: {W}ege und {B}est {P}ractices f{\"u}r serviceorientierte {A}rchitekturen},
 keywords = {Projektmanagement;Serviceorientierte Architektur;Software engineering;Unternehmen},
 address = {Heidelberg},
 edition = {1.},
 publisher = {mitp},
 isbn = {9783826617294}
}


@phdthesis{Hacker.2009,
 abstract = {Thema dieser Arbeit ist die Konzeption der Datenverwaltung eines Systems, welches die R{\"a}umlichkeiten, die organisierten Veranstaltungen und deren Teilnehmer beinhaltet. Zuerst wurde dazu eine allgemeine Theorie erstellt, die die Thematik Rauminformation und Raumverwaltung abstrakt darstellt. Die darauf folgende Analyse der Bedingungen an der Hochschule Neubrandenburg zeigte, dass die Verwaltung durch ein zentrales System erleichtert werden kann. Dies bildet die Grundlage des Vergleiches verschiedener L{\"o}sungsm{\"o}glichkeiten, in dem der Einsatz der Softwarel{\"o}sung HIS der Hochschul Informations System GmbH die besten Erfolgsaussichten bot. Durch eine Testimplementation dieser Software wurde festgestellt, dass diese L{\"o}sung an der Hochschule Neubrandenburg eingesetzt werden kann. Es w{\"u}rde ein funktionierendes zentrales Rauminformations- und -verwaltungssystem darstellen.},
 author = {H{\"a}cker, Jan},
 year = {2009},
 title = {{K}onzeption der {D}atenverwaltung f{\"u}r ein {R}auminformations- und -verwaltungssystem an der {H}ochschule {N}eubrandenburg},
 url = {http://digibib.hs-nb.de/file/dbhsnb\_derivate\_0000000206/Diplomarbeit-Haecker-2009.pdf},
 keywords = {HIS;Raumverwaltung;Informationssystem},
 address = {Neubrandenburg},
 urldate = {11.03.2016},
 publisher = {Fachbereich Landschaftsarchitektur, Geoinformatik, Geod{\"a}sie, Bauingenieurwesen},
 school = {{University of Applied Sciences}}
}


@book{Goring.2009,
 author = {G{\"o}ring, Arne},
 year = {2009},
 title = {{Q}uo vadis {H}ochschulsport? {I}m {W}andel von {H}ochschule und {G}esellschaft},
 address = {G{\"o}ttingen},
 volume = {2},
 publisher = {Univ.-Verl. G{\"o}ttingen},
 isbn = {3940344826},
 series = {{U}niversit{\"a}tsdrucke {G}{\"o}ttingen}
}


@misc{Fowler.2015,
 author = {Fowler, Martin},
 year = {2015},
 title = {{M}icroservices {R}esource {G}uide},
 url = {http://martinfowler.com/microservices/},
 urldate = {16.02.2016}
}


@book{Wolff.2016,
 author = {Wolff, Eberhard},
 year = {2016},
 title = {{M}icroservices: {G}rundlagen flexibler {S}oftwarearchitekturen},
 address = {Heidelberg},
 edition = {1.},
 publisher = {dpunkt},
 isbn = {978-3864903137}
}


@book{Fowler.2003,
 author = {Fowler, Martin},
 year = {2003},
 title = {{P}atterns of enterprise application architecture},
 keywords = {System design;Computer architecture;Application software;Business;Programmatuurtechniek;Bedrijfsorganisatie;Automatisering;T{\'e}cnicas de programa{\c{c}}{\~a}o;Projeto de software (padr{\~o}es);Conception de syst{\`e}mes;Architecture d'ordinateur;Logiciel d'application;D{\'e}veloppement de logiciels;Entreprise;Application industrielle;Anwendungssystem;Objektorientierung;Systementwicklung;Unternehmen},
 address = {Boston},
 publisher = {Addison-Wesley},
 isbn = {9780321127426},
 series = {{T}he {A}ddison-{W}esley signature series}
}


@book{Balzert.1996,
 author = {Balzert, Helmut},
 year = {1996},
 title = {{L}ehrbuch der {S}oftware-{T}echnik - {S}oftware-{E}ntwicklung},
 address = {Heidelberg [u.a.]},
 publisher = {Spektrum Akadem. Verl.},
 isbn = {3827400422},
 series = {{L}ehrb{\"u}cher der {I}nformatik}
}


@book{Balzert.19982001,
 author = {Balzert, Helmut},
 year = {1998-2001},
 title = {{L}ehrbuch der {S}oftware-{T}echnik},
 address = {Heidelberg},
 publisher = {Spektrum Akademischer Verlag},
 isbn = {3827400651}
}


@book{Becker.2011,
 author = {Becker, Alexander},
 year = {2011},
 title = {{N}utzenpotenziale und {H}erausforderungen {S}ervice-orientierter {A}rchitekturen [{E}lektronische {R}essource]   von {A}lexander {B}ecker},
 keywords = {Unternehmen Serviceorientierte Architektur Nutzen Bewertung f Online-Publikation},
 address = {Wiesbaden},
 publisher = {Gabler},
 isbn = {978-3-8349-6228-7}
}


@book{Bengel.2013,
 author = {Bengel, G{\"u}nther},
 year = {2013},
 title = {{G}rundkurs {V}erteilte {S}ysteme: {G}rundlagen und {P}raxis des {C}lient-{S}erver-{C}omputing - {I}nklusive aktueller {T}echnologien wie {W}eb-{S}ervices u. a. - {F}{\"u}r {S}tudenten und {P}raktiker},
 address = {Wiesbaden},
 edition = {4.},
 publisher = {Springer Fachmedien Wiesbaden GmbH},
 isbn = {978-3-8348-1670-2}
}


@book{Bass.2013,
 author = {Bass, Len and Clements, Paul and Kazman, Rick},
 year = {2013},
 title = {{S}oftware architecture in practice},
 keywords = {Software Architecture;System design;Softwarearchitektur;Systementwurf},
 address = {Upper Saddle River and NJ},
 edition = {3rd ed},
 publisher = {Addison-Wesley},
 isbn = {0321815734},
 series = {{S}{E}{I} series in software engineering}
}


@book{Fahlenbock.2010,
 year = {2010},
 title = {{H}ochschulsport-{U}mfrage {N}{R}{W} 2009},
 keywords = {Sportverhalten;Hochschulsport;Online-Befragung},
 address = {Berlin and M{\"u}nster},
 volume = {58},
 publisher = {Lit},
 isbn = {3643106815},
 series = {{S}chriften zur {K}{\"o}rperkultur},
 editor = {Fahlenbock, Michael}
}


@book{Brause.2005,
 author = {Brause, R{\"u}diger},
 year = {2005},
 title = {{K}ompendium der {I}nformationstechnologie: {H}ardware, {S}oftware, {C}lient-{S}erver-{S}ysteme, {N}etzwerke, {D}atenbanken},
 address = {Berlin [u.a.]},
 publisher = {Springer},
 isbn = {3-540-20911-5},
 series = {{X}pert.press}
}


@misc{Browne.09.05.2014,
 abstract = {An explanation of Eric Brewer's CAP theorem, which says you cannot have more than two of Consistency, Availability and Partition-tolerance in web-based distributed systems.},
 author = {Browne, Julian},
 year = {09.05.2014},
 title = {{B}rewer's {C}{A}{P} {T}heorem},
 url = {http://www.julianbrowne.com/article/viewer/brewers-cap-theorem},
 urldate = {11.03.2016}
}


@misc{Fowler.2011,
 abstract = {LMAX is a new retail financial trading platform. As a result it has to process many trades with low latency. The system is built on the JVM platform and centers on a Business Logic Processor that can handle 6 million orders per second on a single thread. The Business Logic Processor runs entirely in-memory using event sourcing. The Business Logic Processor is surrounded by Disruptors - a concurrency component that implements a network of queues that operate without needing locks. During the design process the team concluded that recent directions in high-performance concurrency models using queues are fundamentally at odds with modern CPU design.},
 author = {Fowler, Martin},
 year = {2011},
 title = {{T}he {L}{M}{A}{X} {A}rchitecture},
 url = {http://martinfowler.com/articles/lmax.html},
 urldate = {11.03.2016}
}


@book{Hohpe.2004,
 abstract = {Would you like to use a consistent visual notation for drawing integration solutions? Look inside the front cover. *Do you want to harness the power of asynchronous systems without getting caught in the pitfalls? See {\dq}Thinking Asynchronously{\dq} in the Introduction. *Do you want to know which style of application integration is best for your purposes? See Chapter 2, Integration Styles. *Do you want to learn techniques for processing messages concurrently? See Chapter 10, Competing Consumers and Message Dispatcher. *Do you want to learn how you can track asynchronous messages as they flow across distributed systems? See Chapter 11, Message History and Message Store. *Do you want to understand how a system designed using integration patterns can be implemented using Java Web services, .NET message queuing, and a TIBCO-based publish-subscribe architecture? See Chapter 9, Interlude: Composed Messaging. Utilizing years of practical experience, seasoned experts Gregor Hohpe and Bobby Woolf show how asynchronous messaging has proven to be the best strategy for enterprise integration success. However, building and deploying messaging solutions presents a number of problems for developers.Enterprise Integration Patterns provides an invaluable catalog of sixty-five patterns, with real-world solutions that demonstrate the formidable of messaging and help you to design effective messaging solutions for your enterprise. The authors also include examples covering a variety of different integration technologies, such as JMS, MSMQ, TIBCO ActiveEnterprise, Microsoft BizTalk, SOAP, and XSL. A case study describing a bond trading system illustrates the patterns in practice, and the book offers a look at emerging standards, as well as insights into what the future of enterprise integration might hold. This book provides a consistent vocabulary and visual notation framework to describe large-scale integration solutions across many technologies. It also explores in detail the advantages and limitations of asynchronous messaging architectures. The authors present practical advice on designing code that connects an application to a messaging system, and provide extensive information to help you determine when to send a message, how to route it to the proper destination, and how to monitor the health of a messaging system.If you want to know how to manage, monitor, and maintain a messaging system once it is in use, get this book.},
 author = {Hohpe, Gregor and Woolf, Bobby},
 year = {2004},
 title = {{E}nterprise integration patterns: {D}esigning, building, and deploying messaging solutions},
 keywords = {Telecommunication;Management information systems},
 address = {Boston},
 publisher = {Addison-Wesley},
 isbn = {9780321200686},
 series = {{T}he {A}ddison-{W}esley signature series}
}


@misc{Jungling.2012,
 abstract = {F{\"u}r die Olympischen Spiele m{\"u}ssen die IT-Systeme auf Attacken vorbereitet sein. Auch bei Start und Ziel muss die Technik funktionieren. {\glqq}Welt Online{\grqq} erkl{\"a}rt die Pr{\"a}zision hinter dem Sport.},
 author = {J{\"u}ngling, Thomas},
 year = {2012},
 title = {{D}as ist die {T}echnik hinter den {O}lympischen {S}pielen},
 url = {http://www.welt.de/wissenschaft/article108399782/Das-ist-die-Technik-hinter-den-Olympischen-Spielen.html},
 keywords = {Omega (Uhren);London 2012;Zeitmessung [ks];Zeitmessungen [ks]},
 urldate = {11.03.2016}
}


@article{Leavitt.2010,
 abstract = {Many organizations collect vast amounts of customer, scientific, sales, and other data for future analysis. Traditionally, most of these organizations have stored structured data in relational databases for subsequent access and analysis. However, a growing number of developers and users have begun turning to various types of nonrelational, now frequently called NoSQL-databases. Nonrelational databases, including hierarchical, graph, and object-oriented databases-have been around since the late 1960s. However, new types of NoSQL databases are being developed. And only now are they beginning to gain market traction. Different NoSQL databases take different approaches. What they have in common is that they're not relational. Their primary advantage is that, unlike relational databases, they handle unstructured data such as word-processing files, e-mail, multimedia, and social media efficiently. This paper discuss issues such as limitations, advantages, concerns and doubts regarding NoSQL databases.},
 author = {Leavitt, Neal},
 year = {2010},
 title = {{W}ill {N}o{S}{Q}{L} {D}atabases {L}ive {U}p to {T}heir {P}romise?},
 pages = {12--14},
 volume = {43},
 number = {2},
 issn = {0018-9162},
 journal = {Computer},
 doi = {10.1109/MC.2010.58}
}


@article{Paakkonen.2011,
 author = {P{\"a}{\"a}kk{\"o}nen, Pekka and Pak, Daniel},
 year = {2011},
 title = {{R}eport on {S}calability of database technologies for entertainment services},
 url = {http://virtual.vtt.fi/virtual/nextmedia/Deliverables-2011/D1.2.3.3\_MUMUMESE\_Report\%20on\%20Scalability\%20of\%20database\%20technologies\%20for\%20entertainment\%20services.pdf},
 urldate = {11.03.2016}
}


@article{Pritchett.2008,
 abstract = {Web applications have grown in popularity over the past decade. Whether you are building an application for end users or application developers (i.e., services), your hope is most likely that your application will find broad adoption and with broad adoption will come transactional growth. If your application relies upon persistence, then data storage will probably become your bottleneck. There are two strategies for scaling any application. The first, and by far the easiest, is vertical scaling: moving the application to larger computers. Vertical scaling works reasonably well for data but has several limitations. The most obvious limitation is outgrowing the capacity of the largest system available. Vertical scaling is also expensive, as adding transactional capacity usually requires purchasing the next larger system. Vertical scaling often creates vendor lock, further adding to costs.
Horizontal scaling offers more flexibility but is also considerably more complex. Horizontal data scaling can be performed along two vectors. Functional scaling involves grouping data by function and spreading functional groups across databases. Splitting data within functional areas across multiple databases, or sharding, adds the second dimension to horizontal scaling.},
 author = {Pritchett, Dan},
 year = {2008},
 title = {{B}{A}{S}{E}: {A}{N} {A}{C}{I}{D} {A}{L}{T}{E}{R}{N}{A}{T}{I}{V}{E}: {I}n partitioned databases, trading some consistency for availability can lead to dramatic improvements in scalability},
 pages = {48--55},
 volume = {6},
 number = {3},
 issn = {15427730},
 journal = {Queue},
 doi = {10.1145/1394127.1394128}
}


@misc{Rozendaal.13.13.2011,
 abstract = {Currently many business applications are developed using a very database centric approach, often requiring the use of complex and heavy-weight Object-Relational Mappers (ORMs) to make developers productive. Although improvements have been made (through the use of annotations, reflections, conventions) the core issues remain:

Lack of modularity
High coupling to the used ORM and/or underlying database, making it unnecessarily hard to use alternative (NoSQL) or multiple databases
Hard to understand the full application, due to the complexity of the used ORM
Mutability is in-grained, reducing the possibilities for composition and modularity
Limited possibility for abstraction, due to limitations imposed by the ORM on used data types, etc.
In this talk we'll explore the use of an alternative approach using the techniques pioneered by Domain-Driven Design (DDD) and especially Command-Query Responsibility Segregation (CQRS): Event Sourcing.

Using Event Sourcing the application can be split into two parts:

Domain logic responsible for generating events (command side)
Reporting, view, integration, etc. logic that consumes the generated events ({\dq}query{\dq} side).
Through this explicit notion of change (domain events) the developer is put back in control of the application.

Traditional languages such as Java require a lot of ceremony when implementing event sourcing, obscuring the basic simplicity. Using Scala's flexible syntax and support for light-weight classes, immutable data structures and transactional memory only very little support code is needed to build production ready applications using Event Sourcing. We can start simple and scale up to more complexity only when needed. During this talk we'll take a quick tour through the code you might need to get started.

The goals are to make developers productive while keeping applications understandable and maintainable. This is achieved by:

Putting the developer back into control, instead of a framework
Keeping infrastructure concerns out of your domain code
Manage complexity in a scalable manner. Simple functionality ({\dq}CRUD{\dq}) is easy to implement, while allowing a clear path towards complex behavior and implementation
A simple cost model: the cost of generating, storing, and processing events is clear, as is the cost for querying derived data. With relational databases and ORMs costs are much less clear and often highly dependent on external factors such as configuration, table statistics, etc.
Simple, clearly delineated application components that interact through well-defined interfaces, for both infrastructure and domain code
Mostly immutable data structures with mutation controlled by using Scala's software transactional memory
Some of these concepts were first explored in a series of blog posts and was presentated at ScalaDays in 2011 at Standford University in California.},
 author = {Rozendaal, Erik},
 year = {13.13.2011},
 title = {{E}xploring {L}ightweight {E}vent {S}ourcing},
 series = {{G}{O}{T}{O} {A}msterdam 2011}
}


@phdthesis{Stander.2011,
 abstract = {Datenbanken werden im Computeralltag mittlerweile fl{\"a}chendeckend eingesetzt, u.a. bei:
Desktopapplikationen
Webapplikationen
Enterprisenanwendungen / Gesch{\"a}ftsbetrieb
Privatnutzer
So ist es auch nicht verwunderlich, dass sich mit der gestiegenen Anzahl von Einsatzfeldern auch die Nachfrage zu neuen, flexibleren Datenbanksystemen ge{\"a}ndert hat. Die NoSQL-Bewegung ist - grob zusammengefasst - eine von diesen. Der Name NoSQL steht f{\"u}r not-only-SQL und bedeutet in der Regel, dass neue Ans{\"a}tze bezogen auf die API, Datenverwaltung, Verf{\"u}gbarkeit, Skalierbarkeit und Geschwindigkeit der Datenbanksysteme verfolgt werden. In der Bachelorarbeit m{\"o}chte ich ein herk{\"o}mmliches relationales Datenbanksystem (MySQL) mit einem neunen, nicht-relationalen Datenbanksystem (MongoDB) vergleichen. Beide Datenbanken sind {\"u}ber Open-Source-Lizenzen verf{\"u}gbar, haben eine gro{\ss}e Nutzerzahl (vor allem im Webapplikationsbereich), werden jeweils von einer Firma betreut/vermarktet und werden aktiv weiterentwickelt. Damit soll sichergestellt sein, dass wir hier zwei zeitgem{\"a}{\ss}e Datenbanksysteme vergleichen.
Als Datenmaterial wird die Wikipedia verwendet, da sie zum einen strukturell f{\"u}r eine NoSQLDatenbank pr{\"a}destiniert ist und bis heute offiziell auf einem relationalen Datenbanksystem (MySQL) betrieben wird. Zudem liegen die Datenmengen mit {\"u}ber 2 Millionen Eintr{\"a}gen (entsprechend 7GB an Datenvolumen) in einer {\glqq}businesstauglichen{\grqq} Gr{\"o}{\ss}enordnung und sind freiverf{\"u}gbar.Als non-relationale Datenbank kommt die MongoDB zum Einsatz. Sie ist eine dokumentenbasierte Datenbank mit Eigenschaften einer herk{\"o}mmlichen relationalen Datenbank und deshalb ein ad{\"a}quates Gegenst{\"u}ck zu MySQL. Andere popul{\"a}re NoSQL-Vertreter, wie z.B. CouchDB, sind in ihren Ans{\"a}tzen und Unterschieden wesentlich radikaler. So besitzt die MongoDB ebenfalls Hauptschl{\"u}ssel, Feldindexierung und bietet auch die M{\"o}glichkeit Datens{\"a}tze direkt miteinander verkn{\"u}pfen.
Beim Importvorgang wird f{\"u}r beide Datenbanksysteme jeweils eine angepasste Struktur gew{\"a}hlt, um den abschlie{\ss}enden Geschwindigkeitsvergleich so fair wie m{\"o}glich zu gestalten. Das Ergebnis der Arbeit soll ein {\"u}bersichtlicher Vergleich beider Datenbanksysteme sein. Dabei geht es nicht um das theoretische Aufz{\"a}hlen von Vor- und Nachteilen der jeweiligen Datenbank, sondern um einen praxisnahen Anwendungsfall, der von beiden Datenbanken bew{\"a}ltigt werden muss. Zudem soll gezeigt werden, dass es durchaus Sinn macht, f{\"u}r bestimmte Anwendungszwecke spezielle Datenbanksysteme zu verwenden.},
 author = {St{\"a}nder, Philipp},
 year = {2011},
 title = {{E}in {V}ergleich eines relationalen mit einem non-relationalen {D}atenbanksystems ({M}y{S}{Q}{L} / {M}ongo{D}{B})},
 address = {K{\"o}ln},
 urldate = {11.03.2016},
 publisher = {Institut f{\"u}r Medien- und Phototechnik},
 school = {{Cologne University of Applied Sciences}}
}


@inproceedings{Tudorica.2011,
 author = {Tudorica, Bogdan George and Bucur, Cristian},
 title = {{A} comparison between several {N}o{S}{Q}{L} databases with comments and notes},
 pages = {1--5},
 publisher = {IEEE Computer Society},
 editor = {{IEEE Computer Society}},
 booktitle = {{N}etworking in {E}ducation and {R}esearch},
 year = {2011},
 address = {Los Alamitos and CA},
 doi = {10.1109/RoEduNet.2011.5993686}
}


@misc{vanHoof.2006,
 abstract = {Many people think of SOA as synchronous RPC (mostly over Web services). Others say EDA is SOA. And there are people who say that the best of EDA and SOA is combined in SOA 2.0. But an architectural distinction can be made between a request- and-reply pattern and a publish-and-subscribe pattern. Both patterns are an inverse of each other. Because of the completely different nature and use of the two patterns, it is necessary to be able to distinguish between the both and to name them. You might say making such a distinction is a universal architectural principle. Combining both of the patterns into an increment of the version number of one of them is not a very clever act. It is appropriate and desirable to use the acronyms SOA and EDA to make this distinction, because SOA and EDA are both positioned in the same architectural domain; SOA focusing on (the decomposition of) business functions and EDA focusing on business events. This article explains the differences between the two patterns, when to use the one or the other and how to combine them.},
 author = {van Hoof, Jack},
 year = {2006},
 title = {{H}ow {E}{D}{A} extends {S}{O}{A} and why it is important},
 keywords = {þÿ},
 urldate = {11.03.2016}
}


